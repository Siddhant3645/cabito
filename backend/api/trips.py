# /backend/api/trips.py (Updated for Pagination)
from datetime import datetime, timezone as dt_timezone
from typing import List

from fastapi import APIRouter, Depends, HTTPException, Path as FastApiPath, Request, Query
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

from database import get_db
from models.all_models import UserAccount, UserTrip
from schemas.itinerary_schemas import (MemorySnapshotResponse,
                                         TripCompletionStatus,
                                         TripListResponse, UserTripPydantic)
from services import ai_service
from api.users import get_current_active_user

router = APIRouter()


@router.get("/", response_model=TripListResponse, summary="List User's Trips with Pagination")
async def list_user_trips(
    db: AsyncSession = Depends(get_db),
    current_user: UserAccount = Depends(get_current_active_user),
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(10, ge=1, le=50, description="Number of trips per page"),
):
    """
    Retrieve a paginated list of all trips generated by the currently authenticated user.
    """
    # First, get the total count of trips for this user
    count_stmt = select(func.count()).select_from(UserTrip).where(UserTrip.user_id == current_user.id)
    total_trips_result = await db.execute(count_stmt)
    total_trips = total_trips_result.scalar_one()

    # Then, fetch the trips for the requested page
    offset = (page - 1) * page_size
    stmt = (
        select(UserTrip)
        .where(UserTrip.user_id == current_user.id)
        .order_by(UserTrip.created_at.desc())
        .offset(offset)
        .limit(page_size)
    )
    result = await db.execute(stmt)
    trips = result.scalars().all()

    return TripListResponse(
        trips=[UserTripPydantic.from_orm(trip) for trip in trips],
        total_trips=total_trips,
        page=page,
        page_size=page_size
    )


@router.get("/{trip_uuid}", response_model=UserTripPydantic, summary="Get Trip Details")
async def get_user_trip_details(
    trip_uuid: str = FastApiPath(..., description="The UUID of the trip to retrieve."),
    db: AsyncSession = Depends(get_db),
    current_user: UserAccount = Depends(get_current_active_user),
):
    """
    Retrieve the full details of a specific trip by its UUID.
    """
    stmt = select(UserTrip).where(
        UserTrip.trip_uuid == trip_uuid, UserTrip.user_id == current_user.id
    )
    result = await db.execute(stmt)
    trip = result.scalars().first()
    if not trip:
        raise HTTPException(status_code=404, detail="Trip not found or access denied.")
    return UserTripPydantic.from_orm(trip)


@router.post("/{trip_uuid}/complete", response_model=TripCompletionStatus, summary="Mark Trip as Completed")
async def mark_trip_as_completed(
    trip_uuid: str = FastApiPath(
        ..., description="The UUID of the trip to mark as completed."
    ),
    db: AsyncSession = Depends(get_db),
    current_user: UserAccount = Depends(get_current_active_user),
):
    """
    Mark a specific trip as 'completed'.
    """
    stmt = select(UserTrip).where(
        UserTrip.trip_uuid == trip_uuid, UserTrip.user_id == current_user.id
    )
    result = await db.execute(stmt)
    trip = result.scalars().first()
    if not trip:
        raise HTTPException(status_code=404, detail="Trip not found or access denied.")

    if trip.status == "completed":
        return TripCompletionStatus(
            trip_uuid=trip.trip_uuid,
            status=trip.status,
            marked_completed_at=trip.marked_completed_at,
            message="Trip was already marked as completed.",
        )

    trip.status = "completed"
    trip.marked_completed_at = datetime.now(dt_timezone.utc)
    db.add(trip)
    await db.commit()
    await db.refresh(trip)

    return TripCompletionStatus(
        trip_uuid=trip.trip_uuid,
        status=trip.status,
        marked_completed_at=trip.marked_completed_at,
        message="Trip successfully marked as completed.",
    )


@router.post(
    "/{trip_uuid}/generate-memory-snapshot",
    response_model=MemorySnapshotResponse,
    summary="Generate AI Memory Snapshot"
)
async def generate_trip_memory_snapshot(
    request: Request,
    trip_uuid: str = FastApiPath(
        ..., description="The UUID of the trip for snapshot generation."
    ),
    db: AsyncSession = Depends(get_db),
    current_user: UserAccount = Depends(get_current_active_user),
):
    """
    Generates and saves a narrative 'memory' for a trip using the AI service.
    If a memory already exists, it will be regenerated.
    """
    stmt = select(UserTrip).where(
        UserTrip.trip_uuid == trip_uuid, UserTrip.user_id == current_user.id
    )
    result = await db.execute(stmt)
    trip = result.scalars().first()
    if not trip:
        raise HTTPException(status_code=404, detail="Trip not found or access denied.")

    gemini_model = request.app.state.gemini_model

    snapshot_text = await ai_service.generate_ai_memory_snapshot_text(
        gemini_model=gemini_model, trip=trip
    )

    if snapshot_text and "taking a break" not in snapshot_text.lower():
        trip.memory_snapshot_text = snapshot_text
        trip.updated_at = datetime.now(dt_timezone.utc)
        db.add(trip)
        await db.commit()
        return MemorySnapshotResponse(
            trip_uuid=trip.trip_uuid,
            memory_snapshot_text=snapshot_text,
            message="Memory snapshot generated successfully.",
        )
    else:
        return MemorySnapshotResponse(
            trip_uuid=trip.trip_uuid,
            memory_snapshot_text=None,
            message="Failed to generate memory snapshot.",
        )